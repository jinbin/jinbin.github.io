---
layout: page  
title: The Smallest Distributed System (2)   
category: 技术   
tags: 持续集成    
---
{% include JB/setup %}


##最小的分布式系统(2)

![架构图4](/image/The_Smallest_Distributed_System_04.jpg)

大约1年之前，我们发现当时的架构有些不合理了。尤其是Hub，它上面承担了太多的任务。Hub要接收新的处理请求，处理并推动构建日志，它要同步用户信息到Github，它要通知用户构建是否成功。它跟一大群外部API打交道，全部都是在一个进程中处理。

Hub需要继续演化，但它却不太可能自由扩展。Hub只能以单进程的方式运行，也因此成为我们最有可能发生的单点错误。

Github API是一个有趣的例子。我们是Github API的重度用户，依靠这些API我们的构建任务才能执行。无论是获取构建配置信息，更新构建状态，还是同步用户数据，都离不开这些API。

回顾历史，当这些API中的某一个不可用，hub就会停止当天正在处理的任务，而转移到下一个任务上。所以，当Github API不可用时，我们的很多构建都会失败。

我们对这些API赋予了很多信任，当然现在也一样，但是说到底，这些是我们不能掌控的资源。这些资源不是我们自己来维护，而是由另外的一个团队，在另外的网络系统中，有他们自身的弱点。

我们过去没有这样想。过去我们总是把这些资源当做我们可以信赖的朋友，以为他们随时都会响应我们的请求。

我们错了。

一年之前，这些API无声无息的对某个功能做了修改。这个一个虽然没有文档说明，但是我们非常依赖的功能。这个功能就是这么消无声息的被修改了，于是导致了我们这边的问题。

结果，我们的系统完全乱套了。原因很简单，我们把Github API当做了自己的朋友，我们耐心的等待这些API回应我们的请求。每一次新的提交，我们都等了很长的时间，每次都有几分钟。

我们的超时设置太宽松了。因为这个原因，当对Github API的请求最终超时时，我们的系统也已经发生错误。那天晚上我们花了很长的时间处理这个问题。

即便是小问题，当某个时刻凑到一块了，也能够破坏一个系统。

![架构图5](/image/The_Smallest_Distributed_System_05.jpg)