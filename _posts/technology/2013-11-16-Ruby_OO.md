---
layout: page  
title: Ruby OO   
category: 技术  
tags: Ruby   
---
{% include JB/setup %}

Ruby的OO实在是个常聊常新的话题。  
Ruby号称是完全的面向对象编程语言，"一切皆对象"，所以在Ruby的世界里，你总是可以问:"对象在哪里？"

首先列出一张我见过比较好的Ruby类的关系图：

![Ruby OO](/image/ruby_oo.jpg)

这张图比较清晰的展示了对象,对象的类,Class,Module,Object,Kernel,BasicObject之间的关系。

经常有人混淆的一点是：instance_of 和 subclass，前者是实例与对象的关系，后者是继承的关系。

实例与实例之间共享相同的方法，所以方法并不定义在某个实例中，而是定义在类中。类与类之间在允许情况下可以共享方法，这就有了继承的关系。

在一个类中，方法根据多大程度向外展示，可以分为三种：

- public (default)
没有任何限制
- protected
只能被定义类的对象，或者定义类的子类们的对象所调用
Access is kept within the family.
- private
只能在当前对象的上下文中使用

作为动态语言，Ruby只有当你试图访问受限方法时，才会提示权限错误。

通过Ruby的内省方式我们可以得到一个对象的方法：

- methods
官方文档：Returns a list of the names of **public** and **protected** methods of obj. This will include **all the methods accessible in obj’s ancestors**. If the all parameter is set to *false*, only those methods in the receiver will be listed.
- private_methods
官方文档：Returns the list of private methods accessible to obj. If the all parameter is set to false, only those methods in the receiver will be listed.
- protected_methods
- public_methods

实际上，Object的实例方法都是定义在Module Kernel中的,Objece通过include将Kernel中的实例方法变为了自身的。

这个地方不深究其实也没啥大不了的东西，一深究就会发现水很深...

首先我们来看Ruby怎么实现include:
Ruby implements include very simply: the module that you include is effectively added as a superclass of the class being defined. It’s as if the module was the parent of the class that it is mixed in to.

另外一点是：Module must itself hold a link to the original parent class.

所以，如果想要在Object里面添加方法，可以这样做：  
<code>  
module New  
&nbsp;&nbsp;def new_method  
&nbsp;&nbsp;end  
end   
module Kernel  
&nbsp;&nbsp;include New  
end
new_method
</code>

由于脚本中默认的main是Object的实例，而Object继承自Kernel，BasicObject，所以在Kernel中include新增的new_method方法后，在脚本里就可以直接使用new_method了。  

这逻辑是不是很巧妙？

但是上面这段代码在脚本里执行出错= =！:  
`undefined local variable or method new_method for main:Object`

因为你还需要加上一段：   
<code>
class Object   
&nbsp;&nbsp;include Kernel  
end  
</code>

原因其实也没啥滑头的，留给大家思考了。




